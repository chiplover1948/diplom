\documentclass[oneside,final,14pt]{extreport}
\usepackage[T2A,T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russianb]{babel}
\usepackage{vmargin}
\usepackage{amsmath}
\usepackage{graphicx}
\setpapersize{A4}
\setmarginsrb{2cm}{1.5cm}{1cm}{1.5cm}{0pt}{0mm}{0pt}{13mm}
\usepackage{indentfirst}
\sloppy
\makeatletter
\renewcommand*{\@biblabel}[1]{\hfill#1.}
\makeatother
\newcommand\Chapter[1]{
 \refstepcounter{chapter}
 \chapter*{
  \arabic{chapter}. \raggedright #1
 }
 \addcontentsline{toc}{chapter}{\arabic{chapter}. #1}
}

\begin{document}

\begin{titlepage}
\thispagestyle{empty}
\begin{center}
\vspace{-4cm}

\includegraphics[width=0.5\textwidth]{msu}\\
{Московский государственный университет имени М.В.~Ломоносова}\\
Факультет вычислительной математики и кибернетики\\
Кафедра математической физики

\vspace{5cm}

{\Large Власов~Андрей~Александрович}

\vspace{1cm}

{\Large\bfseries
Решение некоторых задач вычислительной биологии на платформе JavaScript\\}

\vspace{1cm}

{\large ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА}
\end{center}

\vfill

\begin{flushright}
  \textbf{Научный руководитель:}\\
  к.ф.-м.н., доцент\\
  С.Б.~Березин
\end{flushright}

\vfill

\begin{center}
Москва, 2016
\end{center}

\enlargethispage{4\baselineskip}
\end{titlepage}
\setcounter{page}{2}

\tableofcontents

\Chapter{Введение}
	Исследования в области вычислений при помощи ДНК начали проводиться после того, как в 1994 году американский ученый Леонард Адлеман продемонстрировал решение задачи коммивояжера при помощи ДНК путем генерации всех возможных комбинаций путей и их последующей фильтрацией. В основе подобных вычислений лежит модель Уотсона\--Крика, согласно которой четыре азотистых основания (Аденин, Тимин, Гуанин, Цитозин), связываются друг с другом, следуя принципу комплементарности.
	
	Последующие исследования позволили создать работающие в пробирке логические схемы, включающие логические вентили (такие как операции И, ИЛИ и НЕ), основанные на так называемом "<замещении цепи">. В подобных схемах входные данные представляют свободно плавающие цепочки ДНК или РНК, логические вентили состоят из подобных цепочек, одна из которых является потенциальным результатом. Согласно принципу комплементарности входные цепочки могут связываться с цепочками в вентиле, заставляя выходную цепь отсоединиться. В дальнейшем она может послужить входом для следующей операции. Триллионы копий исходной цепочки, логической схемы и выхода образуют "<молекулярный суп">.
	
	Такие ДНК\--компьютеры малоэффективны по сравнению с традиционными, так как химические реакции могут протекать часами, однако они открывают большие возможности при работе в живом организме. Например, они будут способны распознать шаблон зараженной клетки и при необходимости запустить процесс лечения.
	
	Воплощение таких компьютеров в реальности слишком трудоемкое и затратное занятие, поэтому учеными были разработаны программы, позволяющие создавать модели, имитирующие биохимические реакциии, происходящие в клетках. Одной из таких программ является прогрограмма Visual DNA Strand Displacement, разработанная под руководством английского ученого Эндрю Филлипса \cite{soup}. Она позволяет на специальном языке описать систему на основе нуклеиновых кислот и затем симулирует ее поведение в течение времени. Одним из результатов работы программы является система обыкновенных дифференциальных уравнений (ОДУ), определяющая поведение концентраций, взаимодействующих в системе веществ. Эта система и является объектом исследования в данной работе, а для ее решения предлагается написать решатель, использующий неявную формулу дифференцирования назад, позволяющий эффективно решать жесткие системы ОДУ.
	
	Для выполнения работы была выбрана платформа \texttt{JavaScript}, имеющая ряд преимуществ:
\begin{itemize}
\item все вычисления выполняются непосредственно в браузере на клиентском компьютере, требуя от сервера лишь передачу исходных файлов, что позволяет существенно снизить затраты на серверную часть;
\item браузерные приложения одинаково исполняются на любых платформах, в том числе на мобильных.
\end{itemize}
Минусом этой платформы является скорость работы, однако использование подмножества языка \texttt{JavaScript}~--- \texttt{ASM.JS}, программы на котором не интерпретируются в браузере, а предварительно компилируются, позволяет достичь скорости работы, сравнимой с обычными приложениями. Для получения кода на \texttt{ASM.JS} используют программу Emscripten, работающую как компилятор С++. В результате ее работы генерируются файлы с исходным кодом на \texttt{ASM.JS}.

\Chapter{Постановка задачи}

Пропорционально\--интегрирующий (ПИ) регулятор -- устройство в управляющем контуре с обратной связью. ПИ\--регулятор формирует управляющий сигнал, являющийся суммой компонент, одна из которых пропорциональна сигналу рассогласования, а другая --- его интегралу. Общая схема регулятора изображена на рисунке (\ref{controller}). Управляющий сигнал формируется по формуле
\begin{equation}
\label{piFormula}
u(t)=K_p e(t) + K_i \int_0^t e(t)dt,
\end{equation}

\begin{figure}[t]
	\centering
\	\includegraphics[width=0.9\textwidth]{controller}
	\caption{Cхема ПИ--регулятора}
	\label{controller}
\end{figure}

где \(K_p\) и \(K_i\) соответственно коэффициенты пропорциональной и интегральной составляющих, посредством изменения которых производится настройка регулятора.

В статье \cite{picontroller} предлагается несколько вариантов моделирования ПИ-регулятора в среде ДНК с использованием разных веществ в качестве основы для вычислений. Система обыкновенных дифференциальных уравнений, получающаяся в результате работы Visual DSD, показывает изменение концентраций веществ в течение времени. Для исследования модели необходимо решать такие системы, поэтому одной из задач является разработка программы, позволяющей находить с заданной точностью решение задачи Коши (\ref{Cauchy}) для искомой системы. 

\begin{equation}
\label{Cauchy}
\left\{
	\begin{aligned}
		 &\frac{d y_i}{d t}= f_i(y(t),t)\\
		 &y_i(t_0)=y_{i,0}	 
	\end{aligned} \\
\right.,\qquad\qquad
i=1,\ldots ,N.
\end{equation}
Основным требованием к программе является возможность решения \textit{жестких} cистем. Жесткость конкретной системы характеризуется собственными значениями матрицы Якоби, \(\mathbf J\) с элементами  \(J_{ij}\):
\[J_{ij}=\partial f_i / \partial y_j,\qquad\qquad\qquad i,j=1,\ldots N.\]
Система (\ref{Cauchy}) называется \textit{жесткой}, если собственные значения \(\{\lambda_i\}\) матрицы \(\mathbf J\) имеют отрицательные действительные части и сильно отличаются по значению. Число жесткости можно ввести как \(\max|\operatorname{Re}(\lambda_i)| / \min|\operatorname{Re}(\lambda_i)|\).

Значением сигналов в модели ПИ-регулятора служит разность концентраций двух веществ, представляющих собой комплементарные цепочки ДНК. Основная задача состоит в том, чтобы исследовать влияние небольшого отклонения начальной концентрации от заданного значения. Так как получающиеся в результате моделирования системы уравнений не поддаются аналитическому исследованию, предлагается проводить исследование на устойчивость, беря в качестве начальных концентраций реализации нормально распределенной случайной величины. Для каждого значения должна решаться система с соответствующим граничным условием.

\Chapter{Решение жестких систем ОДУ}

\section{Описание метода}

\subsection{Общий алгоритм}


В работе используется метод, описанный в статье \cite{lsode}. На вход алгоритму подается начальное условие и вектор-функция правой части.      Для нахождения приближения решения на \(n\)-м шаге используется схема "<предиктор-корректор"> с явным методом в качестве предиктора и итерациями Ньютона-Рафсона для неявного метода в качестве корректора. На каждом шаге оценивается погрешность аппроксимации и принимается соответствующее решение об изменении порядка метода и размера шага.

\subsection{Формула дифференцирования назад}
В основе метода лежит формула дифференцирования назад, относящаяся к 
линейным многошаговым методам, имеющим следующий общий вид:
\[\bar Y_n=\sum_{j=1}^{q_1} \alpha_j\bar Y_{n-j}+h_n\sum_{j=0}^{q_2} \beta_j\bar f_{n-j}.\]
При \(q_1=q\) и \(q_2=0\) получим формулу дифференцирования назад порядка \(q\). \(\bar Y_n\)~здесь является приближением решения на \(n\)-м шаге и состоит их \(N \ge 1\)~компонент.
\[\bar Y_n=(Y_{1,n},Y_{2,n}\ldots Y_{N,n})^T.\]
Тогда численный метод принимает вид
\[\bar Y_n=\sum_{j=1}^{q} \alpha_j\bar Y_{n-j}+h_n\beta_0\bar f_{n}.\]
Перепишем его в более удобном для дальнейших рассуждений виде:

\begin{equation}
\label{bdf}
	\bar Y_n=\bar\Psi_n+h_n\beta_0\bar f(\bar Y_n).
\end{equation}
\begin{equation}
\label{psi}
	\bar \Psi_n=\sum_{j=1}^{q} \alpha_j\bar Y_{n-j}.
\end{equation}

\subsection{Схема "<предиктор-корректор">}
Чтобы найти приближение решения на очередном шаге, используется схема "<предиктор-корректор">, где в качестве предиктора выступает явная формула дифференцирования назад:

\[\bar Y_n=\sum_{j=1}^{q} \alpha_j^*\bar Y_{n-j}+h_n\beta_1^*\bar f_{n-1}\]
с коэффициентами \(\alpha^*\) и \(\beta^*\), взятыми таким образом, чтобы формула была точна для многочленов степени \(q\).

Предсказанное предиктором значение затем берется в качестве начального приближения итерационного метода:
\[\bar Y_n^{[0]}=\sum_{j=1}^{q} \alpha_j^*\bar Y_{n-j}+h_n\beta_1^*\bar Y_{n-1}^{'}.\]
 На каждом шаге \(m\) корректора аппроксимация производной решения \(h_n\bar Y_n^{'}\) находится из соотношения
\begin{equation}
\bar Y_n^{[m]}=\bar\Psi_n+\beta_0 h_n\bar Y_n^{'[m]}.
\end{equation}

\subsection{Метод Ньютона-Рафсона}
В итерационном процессе используется метод Ньютона для систем уравнений. Описание можно прочитать в книге \cite{andreev}. Перепишем формулу (\ref{bdf}) в виде:
\[
\mathbf{\bar R}(\bar Y_n)= \bar Y_n-\bar\Psi_n-h_n\beta_0\bar f(\bar Y_n)=0.
\]
Тогда нахождение решения (\ref{bdf}) эквивалентно поиску нуля \(\mathbf{\bar R}\). Используя метод Ньютона, получим итерационную последовательность:
\[
\mathbf P(\bar Y_n^{[m+1]}-\bar Y_n^{[m]})=-\mathbf{\bar R}(\bar Y_n^{[m]})=\bar\Psi_n+h_n\beta_0\bar f(\bar Y_n^{[m]})-\bar Y_n^{[m]}
,\]
или в раскрытом относительно \(\bar Y_n^{[m+1]}\) виде:
\begin{equation}
\label{newton}
\bar Y_n^{[m+1]}=\bar Y_n^{[m]}+\beta_0\mathbf P^{-1}\bar g(\bar Y_n^{[m]});
\end{equation}
\[
g(\bar Y_n^{[m]})=h_n\bar f(\bar Y_n^{[m]})-h_n\bar Y_n^{'[m]},
\]
где \(\mathbf P\)~---~матрица размерности \(N\times N\):
\[
\mathbf P=\partial\mathbf{\bar R} / \partial\bar Y=\mathbf I-h_n\beta_0 \mathbf J.
\]


\section{Матричное представление}

\subsection{Обычная матрица истории}
При нахожении приближения \(n\)-го решения для использования формулы дифференцирования назад необходимы приближения в \(q\) предыдущих точках и приближение \(h_n\bar Y_{n-1}^{'}\) в \(n-1\) точке. Их можно хранить в векторе истории
\[\mathbf w_{n-1}=(\bar Y_{n-1} , h_n\bar Y_{n-1}^{'} , \bar Y_{n-2} , \cdots , \bar Y_{n-q})
,\]
на самом деле являющимся матрицей порядка \(N\times q+1\):
\begin{equation}
\label{history}
\mathbf w_{n-1}=
\begin{pmatrix}
	Y_{1,n-1} & h_n Y_{1,n-1}^{'} & Y_{1,n-2} & \cdots &  Y_{1,n-q}\\
	Y_{2,n-1} & h_n Y_{2,n-1}^{'} & Y_{2,n-2} & \cdots &  Y_{2,n-q}\\
	\vdots & \vdots & \vdots &  &  \vdots\\
	Y_{N,n-1} & h_n Y_{N,n-1}^{'} & Y_{N,n-2} & \cdots &  Y_{N,n-q}\\
\end{pmatrix}.
\end{equation}

Формула для нахождения \(h_n\bar Y_{n}^{'[0]}\) получается из соотношений:
\[
h_n\bar Y_{n}^{'[0]}=\sum_{j=1}^q\left(\frac{\alpha_j^*-\alpha_j}{\beta_0}\right)\bar Y_{n-j}+\frac{\beta_1^*}{\beta_0}h_n\bar Y_{n-1}^{'}.
\]
Таким образом, шаг предиктора можно реализовать единственным преобразованием
\begin{equation}
\label{predictor}
\mathbf w_n^{[0]}=\mathbf w_{n-1} \mathbf B ,\end{equation}
где \(\mathbf B\) является матрицей следующего вида:
\begin{equation}
\label{B}
\mathbf{B}=
\begin{pmatrix}
\alpha_1^* & \frac{\alpha_1^*-\alpha_1}{\beta_0} & 1 & 0 & 0 & \cdots & 0\\
\beta_1^* & \frac{\beta_1^*}{\beta_0} & 0 & 0 & 0 & \cdots & 0\\
\alpha_2^* & \frac{\alpha_2^*-\alpha_2}{\beta_0} & 0 & 1 & 0 & \cdots & 0\\
\alpha_3^* & \frac{\alpha_3^*-\alpha_3}{\beta_0} & 0 & 0 & 1 & \cdots & 0\\
\cdot & \cdot & \cdot & \cdot & \cdot & \cdots & \cdot \\
\alpha_{q-1}^* & \frac{\alpha_{q-1}^*-\alpha_{q-1}}{\beta_0} & 0 & 0 & 0 & \cdots & 1\\
\alpha_q^* & \frac{\alpha_q^*-\alpha_q}{\beta_0} & 0 & 0 & 0 & \cdots & 0\\
\end{pmatrix}.
\end{equation}
Шаг корректора, соответственно, преобразуется следующим образом: 
\begin{equation}
\label{corrector}
\mathbf w_n^{[m+1]}=\mathbf w_n^{[m]}+\mathbf P^{-1}\bar g(\bar Y_n^{[m]})\bar k,
\end{equation}
где
\[\bar k=(\beta_0, 1,0,\ldots,0).\]

\subsection{Матрица истории Нордсика}
Главный недостаток представления (\ref{history}) в том, что при изменении шага необходимо пересчитать приближенные решения во всех \(q\) предыдущих точках. Однако есть способ избежать этого, воспользовавшись для хранения результатов вектором Нордсика:
\[\mathbf z_{n-1}=\left(\bar Y_{n-1},h_n\bar Y_{n-1}^{'}, \frac{h_n^2}{2!}\bar Y_{n-1}^{''},\ldots,\frac{h_n^q}{q!}\bar Y_{n-1}^{(q)}\right).\]
Этот вектор связан с (\ref{history}) преобразованием:
\[\mathbf z_{n-1}=\mathbf w_{n-1} \mathbf Q,\]
где \(\mathbf Q\) --- невырожденная матрица размера \(L \times L\). Она не зависит от размера шага, так как используются приближения производных вместо решений. Применяя то же преобразование \(\mathbf Q\) к (\ref{predictor}), получаем:
\[
\mathbf z_n^{[0]}=\mathbf w_n^{[0]}\mathbf Q=\mathbf w_{n-1}\mathbf{B Q}=\mathbf z_{n-1}\mathbf Q^{-1}\mathbf{B Q}=\mathbf z_{n-1}\mathbf A
.\]

Главным преимуществом использования матрицы Нордсика является простота изменения размера шага: для этого достоточно лишь умножить матрицу на матрицу масштаба:
\[\mathbf z_{n-1}:=\mathbf z_{n-1} \mathbf C,\]
где
\[\mathbf C=
\begin{pmatrix}
	1 &   & & & 0\\
	  & r & & &\\
	  &   & r^2 & &\\
	  &   &  & \ddots &\\
	0 &   &  &  & r^q\\
\end{pmatrix}.
\]
Уравнение метода--корректора, соотвествующее (\ref{corrector}) преобразуется к виду:
\[
\mathbf z_n^{[m+1]}=\mathbf w_n^{[m+1]}\mathbf Q=\mathbf w_n^{[m]}\mathbf Q+\mathbf P^{-1}\bar g(\bar Y_n^{[m]})\bar k\mathbf Q=\mathbf z_{n}^{[m]}+\mathbf P^{-1}\bar g(\bar Y_n^{[m]})\bar l;
\]
\[
\bar l=\bar k\mathbf Q;
\]
\begin{equation}
\label{nordseick:iteration}
\mathbf z_m^{[m+1]}=\mathbf z_n^{[0]}+\sum_{j=0}^m\mathbf P^{-1}\bar g(\bar Y_n^{[j]})\bar l=\mathbf z_n^{[0]}+\bar e_n^{[m+1]}\bar l
,\end{equation}
где
\[\bar e_n^{[m+1]}=\sum_{j=0}^m\mathbf P^{-1}\bar g(\bar Y_n^{[j]}),\]
или
\[\bar e_n^{[m+1]}=\bar e_n^{[m]}+\mathbf P^{-1}\bar g(\bar Y_n^{[m]}).\]
Функцию \(\bar g(\bar Y_n^{[m]})\) можно переписать в виде
\[\bar g(\bar Y_n^{[m]})=h_n\bar f(\bar Y_n^{[m]})-h_n\bar Y_n^{'[0]}-\bar e_n^{[m]}.\]

\subsection{Погрешность аппроксимации}

Погрешность аппроксимации показывает, насколько приближенное решение отличается от точного. Погрешность аппроксимации для метода (\ref{bdf}), нормализованная на \(\beta_0\), будет выглядеть следующим образом:
\begin{equation}
\label{truncation}
\bar d_n=\sum_{j=0}^q\left(\frac{\alpha_j}{\beta_0}\right)\bar y(t_{n-j})+h_n\bar y^{'}(t_n).
\end{equation}
После разложения в ряд Тейлора  (\ref{truncation}) примет вид:
\[
\bar d_n=\sum_{k=0}^{\infty}C_k h_n^k \bar y^{(k)}(t_n),
\]
	где \(\{C_k\}\) являются константами. Если метод имеет порядок аппроксимации \(q\), тогда \(C_0=C_1=\ldots=C_q=0\), и \(C_{q+1}\neq0\). Таким образом, погрешность аппроксимации равна:
\[
\bar d_n=C_{q+1} h_n^{q+1} \bar y^{(q+1)}(t_n)+O(h_n^{q+2}),
\]
причем для формулы дифференцирования назад константа \(C_{q+1}=\frac{1}{q+1}.\)

Чтобы оценить насколько полученное решение близко к точному, неоходимо численное приближение погрешности аппроксимации, что легко сделать при использовании вектора Нордсика:
\begin{equation}
\label{truncation:der}
\mathbf z_n(q)-\mathbf z_n^{[0]}(q)=\frac{h_n^q}{q!}\bar Y_n^{(q)}-\frac{h_n^q}{q!}\bar Y_{n-1}^{(q)}=\frac{h_n^{q+1}}{q!}\bar Y_n^{(q+1)} + O(h_n^{q+2}).
\end{equation}
Учитывая (\ref{nordseick:iteration}), получим, что
\begin{equation}
\label{truncation:en}
\mathbf z_n(q)-\mathbf z_n^{[0]}(q)=l_q\bar e_n.
\end{equation}
Используя (\ref{truncation:der}) и (\ref{truncation:en}), получим:
\[
h_n^{q+1}\bar Y_n^{(q+1)}\cong q!l_q\bar e_n,
\]
или
\[
\bar d_n=C_{q+1}q!\bar e_n.
\]
Таким образом, мы получили оценку для погрешности аппроксимации и теперь можем выяснить, насколько точно полученное решение.

\Chapter{Программная реализация}

\section{Решатель уравнений на \texttt{C++}}

Программа, решающая систему ОДУ методом дифференцирования назад, реализована в виде библиотеки на \texttt{C++} в соответствии со статьей \cite{lsode}. Разработанная библиотека имеет следующую структуру: основной класс \texttt{Gear} представляет собой решатель, при вызове конструктора которого задаются начальные данные, правая часть и различные параметры. Для получения решения в следующей точке необходимо вызвать метод \texttt{Solve}. В случае, если задан выходной шаг, в выходной точке производится линейная интерполяция между двумя решениями, найденными с необходимой точностью.

\begin{verbatim}
class Gear
{
public:
    Gear(double, Vector&, RightSide *, Options &);
    SolPoint Solve();
private:
    RightSide *rightSide;
    Options opts;
    NordsieckState currstate;
    int n;
    
    void Corrector(bool &);
    void Predictor();    
    ...
};
\end{verbatim}

\section{Использование Embind}
Для того, чтобы можно было создавать и использовать экземпляры классов С++ в JavaScript коде, необходимо создать "<привязки">. Для этого используется технология \texttt{embind} \cite{emscripten}. Приведенный ниже код осуществляет связывание объектов \texttt{С++} с \texttt{JavaScript} объектами.
\begin{verbatim}
#include "solver/Solver.h"
#include <emscripten/bind.h>

using namespace emscripten;

Gear *GetSolver(double t0, Vector &x0,
                std::uintptr_t f, Options &opts) {
    return new Gear(t0, x0, reinterpret_cast <RightSide *>(f), opts);
}

EMSCRIPTEN_BINDINGS(solver) {
    class_<Vector>("Vector")
    .constructor<int>()
        .function("SetElement", &Vector::SetElement)
        .function("GetElement", &Vector::GetElement)
        .function("Print", &Vector::Print);
    class_<Gear>("Gear")
        .constructor(&GetSolver, allow_raw_pointers())
        .function("Solve", &Gear::Solve);

    class_<Options>("Options")
        .constructor<>();
        		
    class_<SolPoint>("SolPoint")
        .constructor<double, Vector>()
        .function("Time", &SolPoint::GetTime)
        .function("Solve", &SolPoint::GetSolve)
        .function("Print", &SolPoint::Print);
}
\end{verbatim}
В результате, используя оттранслированный файл на JavaScript, можно применять к коду веб-приложения конструкции вида \texttt{var v = new Module.Vector(3)} и обращаться к этой переменой, используя описанный интерфейс.

\section{Решатель систем ОДУ}

Для проверки правильности работы программы и измерения скорости работы был написан пример веб-страницы с решением задачи химической кинетики и отображением решений на графике (рисунок \ref{graph}). Жесткая задача задается следующей системой уравнений:
\[
\left\{
\begin{aligned}
	\dot y_0 &= -0.1y_0+10^2y_1y_2\\ 
	\dot y_1 &= 0.1y_0-10^2y_1y_2-10^3y_1\\
	\dot y_2 &= 10^3y_1\\
\end{aligned}
\right.
\]
с начальным условием 
\[
t_0=0;
\]
\[
\bar y(t_0)=(1,0,0)^T.
\]

\begin{figure}[h]
	\centering
\	\includegraphics[width=1\textwidth]{graph}
	\caption{Задача химической кинетики}
	\label{graph}
\end{figure}



\section{Веб-приложение для исследования модели ПИ-регулятора}
Веб-приложение было разработано на языке TypeScript, транслируемом в обычный JavaScript. Оно позволяет задавать такие параметры, как дисперсия случайной величины, количество проводимых экспериментов и шаг интерполяции, необходимый ввиду использования адаптивного шага при вычислениях. Он может отличаться для каждого эксперимента, поэтому для  обеспечения одинакового количества точек каждого решения используется линейная интерполяция.  Такой подход позволяет закрасить область между максимальным и минимальным решениями, что удобно для визуального исследования.

 Для использования решателя с исходным кодом на ASM.JS был описан класс, инкапсулирующий взаимодействие с кросскомпилированной библиоткой. Он позволяет оперировать при использовании решателя обычными JavaScript массивами в качестве векторов. Результат работы программы показан на рисунке \ref{result}. 
 
 Области между соответствующими минимальными и максимальными решениями закрашиваются, линией отображается медиана значений разных экспериментов в каждой точке. Красным обозначен опорный сигнал, синим --- сигнал на выходе регулятора, серым --- управляемый сигнал и зеленым --- внешняя нагрузка на устройство. В моменты времени, соответствующие значениям 50000 и 100000 опорный сигнал изменяется, чтобы продемонстрировать верную работу ПИ-регулятора.

\begin{figure}[h]
	\centering
\	\includegraphics[width=0.93\textwidth]{result}
	\caption{Результат работы программы}
	\label{result}
\end{figure}

\Chapter{Заключение}

В результате проделанной работы были выполнены все поставленные задачи. На языке C++ написана библиотека, использующая формулу дифференцирования назад с адаптивным шагом для решения задачи Коши с задаваемыми правой частью и граничным условием. Библиотека кросскомпилирована в ASM.JS и на ее основе разработано веб-приложение для исследования модели ПИ-регулятора в среде ДНК-вычислений.

	В результате проведенного сравнения скорости работы решателя на ASM.JS и C++ было установлено, что решение системы уравнений с помощью кросскомпилированной библиотеки занимает приблизительно на 20\% больше времени, чем при использовании оригинального C++ приложения, что является отличным результатом для браузерных вычислений.

\begin{thebibliography}{00}
\addcontentsline{toc}{chapter}{Литература}
\bibitem{lsode}K. Radhakrishnan and A. C. Hindmarsh, "Description and Use of 
LSODE, the Livermore Solver for Ordinary 
Differential Equations," LLNL report UCRL-ID-113855, December 1993
\bibitem{andreev}Андреев В.Б. Численные методы. М.: МАКС Пресс, 2013.-336с.
\bibitem{emscripten}Emscripten documentation: URL: http://kripken.github.io/emscripten-site/
\bibitem{picontroller}Boyan Yordanov, Jongmin Kim, Rasmus L. Petersen, Angelina Shudy, Vishwesh V. Kulkarni, and Andrew Phillips, Computational design of nucleic acid feedback control circuits, in ACS Synthetic Biology, vol. 3, no. 8, pp. 600-616, American Chemical Society, July 2014
\bibitem{soup}Computing with soup. The Economist, 3 March 2012.
\end{thebibliography}

\end{document}
